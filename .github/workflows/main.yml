# Имя workflow, оно будет использоваться в интерфейсе GitHub Actions
name: Main Taski Workflow

# Перечень событий-триггеров, при которых должен запускаться workflow. Триггеров может быть несколько
on:
  # Событие push (это и есть git push) возникает, когда изменения исходного кода приходят на сервер GitHub
  push:
    # Отслеживаем изменения только в ветке (branches) main
    branches:
      - main

# Список действий, которые должны выполниться после срабатывания триггера
jobs:
  # Задача, которую будем выпонлнять (имя задачи даем сами)
  tests:
    # Определяет, в каком окружении будут запущены все команды этой задачи. Окружение создаёт на своём сервере GitHub Actions.
    runs-on: ubuntu-latest

    # Блок services аналогичен docker-compose.yml - В нем указываем названия и описания контейнеров, которые должны быть запущены
    services:
      # Имя и описание контейнера; имя выбирает разработчик. 
      # Это контейнер с сервером PostgreSQL
      postgres:
        # Из какого образа создать запустить контейнер (если уже есть готовый образ):
        image: postgres:13.10
        # Вместо указания файла .env (файл с переменными окружения в котором хранятся "секреты") указываем все данные в открытом виде, 
        # т.к. эта база будет работать только во время прогона тестов
        # Указываем имя и пароль пользователя, которые необходимы для жоступа к БД, а так же имя создаваемой тестовой базы
        env:
          POSTGRES_USER: django_user
          POSTGRES_PASSWORD: django_password
          POSTGRES_DB: django_db
        # Ключ ports устанавливает перенаправление всех запросов с порта 5432 хоста на порт 5432 контейнера
        # 5432- это порт по умолчанию для PostgreSQL, т.е. при запросе к PostgreSQL запрос по умолчанию приходит именно на порт 5432 хоста (раннера).
        # Далее мы прокидываем порт 5432 хоста (раннера) на такой же порт контейнера
        ports:
          - 5432:5432
        # Эта конструкция описывает проверку готовности сервиса postgres
        # Если её не будет, то тесты могут запуститься раньше, чем сервер PostgreSQL
        # В результате тесты решат, что базы нет и упадут
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5


    # Каждая отдельная задача делится на шаги — steps. Каждый шаг — это отдельная команда.
    # Перечень шагов форматируется в виде списка словарей ":" (словарь)
    # В начале каждого шага ставится символ "-" (список)
    steps:
      # На GitHub Actions есть готовые описания шагов, их можно использовать в своих workflow.
      # Применим готовое описание шага для получения исходного кода
      # Каждому шагу можно дать имя — для этого применяется ключ name. Имя шага задаём сами (например, Check out code)

      # Копируем код проекта в рабочую директорию раннера
      - name: Check out code 
        # Для подключения стороннего workflow вместо ключа run применяется ключ uses
        # Берём готовое решение из библиотеки GitHub Actions
        uses: actions/checkout@v3
        
      # Устанавливаем Python - берём готовое решение из библиотеки GitHub Actions
      - name: Set up Python
        uses: actions/setup-python@v4
        # В action setup-python@v4 передаём параметр — версию Python
        with:
          python-version: 3.9

      # Обновляем pip, устанавливаем flake8 и flake8-isort, устанавливаем зависимости проекта
      - name: Install dependencies
        # В ключе run хранится команда, которая будет выполнена в терминале окружения на раннере (на сервере для выполнения задач, который предоставлен сервисом GitHub Actions)
        # Если надо выполнить сразу несколько команд, после run ставится символ | (вертикальная черта, pipe) и ниже построчно пишутся команды:
        run: |
          python -m pip install --upgrade pip 
          pip install flake8==6.0.0 flake8-isort==6.0.0
          pip install -r ./backend/requirements.txt 
      
      # Запускаем flake8 и тесты из tests.py (из backend/api)
      # Так же укажем переменные для доступа к БД
      - name: Test with flake8 and django tests
      # Добавляем указанные выше env-переменные для доступа к созданной выше БД
        env:
          POSTGRES_USER: django_user
          POSTGRES_PASSWORD: django_password
          POSTGRES_DB: django_db
          # Сервер БД PostgreSQL запущен в контейнере Docker, а порт хоста (5432) проброшен на порт контейнера (5432) (см по тексту выше в блоке services)
          # Поэтому подключаемся к 127.0.0.1:5432 (к хосту) и попадает на порт 5432 контейнера
          # Адрес, по которому Django будет соединяться с базой данных.
          DB_HOST: 127.0.0.1
          # Порт, по которому Django будет обращаться к базе данных. 5432 — это порт по умолчанию для PostgreSQL
          DB_PORT: 5432
        # В ключе run хранится команда, которая будет выполнена в терминале окружения на раннере (на сервере для выполнения задач, который предоставлен сервисом GitHub Actions)
        # Вызываем flake8 и указываем ему, что нужно проверить файлы только в папке backend/
        # Далее перейти в папку backend (cd backend/) и запустить все тесты проекта (python manage.py test)
        run: |
          python -m flake8 backend/
          cd backend/
          python manage.py test
