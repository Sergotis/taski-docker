# Имя workflow, оно будет использоваться в интерфейсе GitHub Actions
name: Main Taski Workflow

# Перечень событий-триггеров, при которых должен запускаться workflow. Триггеров может быть несколько
on:
  # Событие push (это и есть git push) возникает, когда изменения исходного кода приходят на сервер GitHub
  push:
    # Отслеживаем изменения только в ветке (branches) main
    branches:
      - main


# Список действий, которые должны выполниться после срабатывания триггера
jobs:
  # Задача, которую будем выполнять (имя задачи "tests" задаем сами)
  # Задача для тестирования приложения
  tests:
    # Каждой задаче (а из может быть несколько) можно дать имя — для этого применяется ключ name.
    name: Сopying the code to the runner, checking with the linter and running tests
    # Определяет, в каком окружении будут запущены все команды этой задачи. Окружение создаёт на своём сервере GitHub Actions.
    runs-on: ubuntu-latest

    # Блок services аналогичен docker-compose.yml - В нем указываем названия и описания контейнеров, которые должны быть запущены
    services:
      # Имя и описание контейнера; имя выбирает разработчик. 
      # Это контейнер с сервером PostgreSQL
      postgres:
        # Из какого образа создать запустить контейнер (если уже есть готовый образ):
        image: postgres:13.10
        # Вместо указания файла .env (файл с переменными окружения в котором хранятся "секреты") указываем все данные в открытом виде, 
        # т.к. эта база будет работать только во время прогона тестов
        # Указываем имя и пароль пользователя, которые необходимы для жоступа к БД, а так же имя создаваемой тестовой базы
        env:
          POSTGRES_USER: django_user
          POSTGRES_PASSWORD: django_password
          POSTGRES_DB: django_db
        # Ключ ports устанавливает перенаправление всех запросов с порта 5432 хоста на порт 5432 контейнера
        # 5432- это порт по умолчанию для PostgreSQL, т.е. при запросе к PostgreSQL запрос по умолчанию приходит именно на порт 5432 хоста (раннера).
        # Далее мы прокидываем порт 5432 хоста (раннера) на такой же порт контейнера
        ports:
          - 5432:5432
        # Эта конструкция описывает проверку готовности сервиса postgres
        # Если её не будет, то тесты могут запуститься раньше, чем сервер PostgreSQL
        # В результате тесты решат, что базы нет и упадут
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5


    # Каждая отдельная задача делится на шаги — steps. Каждый шаг — это отдельная команда.
    # Перечень шагов форматируется в виде списка словарей ":" (словарь)
    # В начале каждого шага ставится символ "-" (список)
    steps:
      # На GitHub Actions есть готовые описания шагов, их можно использовать в своих workflow.
      # Применим готовое описание шага для получения исходного кода
      # Каждому шагу можно дать имя — для этого применяется ключ name. Имя шага задаём сами (например, Check out code)

      # Копируем код проекта в рабочую директорию раннера
      - name: Check out code 
        # Для подключения стороннего workflow вместо ключа run применяется ключ uses
        # Берём готовое решение из библиотеки GitHub Actions
        uses: actions/checkout@v3
        
      # Устанавливаем Python - берём готовое решение из библиотеки GitHub Actions
      - name: Set up Python
        uses: actions/setup-python@v4
        # В action setup-python@v4 передаём параметр — версию Python
        with:
          python-version: 3.9

      # Обновляем pip, устанавливаем flake8 и flake8-isort, устанавливаем зависимости проекта
      - name: Install dependencies
        # В ключе run хранится команда, которая будет выполнена в терминале окружения на раннере (на сервере для выполнения задач, который предоставлен сервисом GitHub Actions)
        # Если надо выполнить сразу несколько команд, после run ставится символ | (вертикальная черта, pipe) и ниже построчно пишутся команды:
        run: |
          python -m pip install --upgrade pip 
          pip install flake8==6.0.0 flake8-isort==6.0.0
          pip install -r ./backend/requirements.txt 
      
      # Запускаем flake8 и тесты из tests.py (из backend/api)
      # Так же укажем переменные для доступа к БД
      - name: Test with flake8 and django tests
      # Добавляем указанные выше env-переменные для доступа к созданной выше БД
        env:
          POSTGRES_USER: django_user
          POSTGRES_PASSWORD: django_password
          POSTGRES_DB: django_db
          # Сервер БД PostgreSQL запущен в контейнере Docker, а порт хоста (5432) проброшен на порт контейнера (5432) (см по тексту выше в блоке services)
          # Поэтому подключаемся к 127.0.0.1:5432 (к хосту) и попадает на порт 5432 контейнера
          # Адрес, по которому Django будет соединяться с базой данных.
          DB_HOST: 127.0.0.1
          # Порт, по которому Django будет обращаться к базе данных. 5432 — это порт по умолчанию для PostgreSQL
          DB_PORT: 5432
        # В ключе run хранится команда, которая будет выполнена в терминале окружения на раннере (на сервере для выполнения задач, который предоставлен сервисом GitHub Actions)
        # Вызываем flake8 и указываем ему, что нужно проверить файлы только в папке backend/
        # Далее перейти в папку backend (cd backend/) и запустить все тесты проекта (python manage.py test)
        run: |
          python -m flake8 backend/
          cd backend/
          python manage.py test

  # Задача для сбора и отправки образа БЕКЕНДА приложения на Docker Hub
  build_backend_and_push_to_docker_hub:
    # Каждой задаче (а из может быть несколько) можно дать имя — для этого применяется ключ name.
    name: Push backend Docker image to DockerHub
    # Определяет, в каком окружении будут запущены все команды этой задачи. Окружение создаёт на своём сервере GitHub Actions.
    runs-on: ubuntu-latest
    # Не выполнять сразу, ждать, пока выполнится задача "tests" (см. выше)
    needs: tests
    # Каждая отдельная задача делится на шаги — steps. Каждый шаг — это отдельная команда.
    steps:
      # Копируем код проекта в рабочую директорию раннера
      - name: Check out the repo
        # Для подключения стороннего workflow вместо ключа run применяется ключ uses
        # Берём готовое решение из библиотеки GitHub Actions
        uses: actions/checkout@v3

      # Развёртывание Docker на раннере
      - name: Set up Docker Buildx
        # Установка сборщика контейнеров Docker
        uses: docker/setup-buildx-action@v2
      
      # Авторизация на Docker Hub
      - name: Login to Docker 
        uses: docker/login-action@v2
        # При помощи with передаём в action параметры username и password для авторизации
        # Держать эти жанные прямо в текущем коде нельзя (он ведь будет запушен на гитаб)
        # Поэтому сохраняем их в репозитории проекта на GITHUB в ввиде констант (DOCKER_USERNAME и DOCKER_PASSWORD)
        # А далее передаем в формате ниже:
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      # Одновременный билд образа и пуш собранного образа в Docker Hub
      - name: Push to DockerHub
        uses: docker/build-push-action@v4
        with:
          # Параметр context: ./backend/ указывает, что нужный Dockerfile находится в ./backend/
          # "." - это значит текущая дериктория, из которой далее переходим в backend
          context: ./backend/
          # Параметр push: true указывает, что образ нужно не только собрать, но и отправить на Docker Hub
          push: true
          # В параметре tags задаётся название и тег для образа.
          # Для каждого пересобранного образа устанавливаем тег latest, чтобы потом на сервере и в docker-compose.yml не указывать версию
          # Указываем в формате: ваш-логин-на-docker-hub/taski_backend:latest 
          tags: sergotis/taski_backend:latest 


  frontend_tests:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    - name: Set up nodeJS
      # Это готовый воркфлоу для установки Node.js на раннер
      uses: actions/setup-node@v3
      with:
        # Это параметр воркфлоу, указывающий нужную версию Node.js
        node-version: 18

    - name: Install dependencies
      # Эта команда устанавливает зависимости для фронтенда
      run: |
        cd frontend/
        npm ci

    - name: Test frontend
      # Запускаем тесты
      run: |
        cd frontend/
        npm run test


  build_frontend_and_push_to_docker_hub:
    name: Push frontend Docker image to DockerHub
    runs-on: ubuntu-latest
    needs: frontend_tests
    steps:
      - name: Check out the repo
        uses: actions/checkout@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: Login to Docker 
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Push to DockerHub
        uses: docker/build-push-action@v4
        with:
          context: ./frontend/
          push: true
          tags: sergotis/taski_frontend:latest


  build_gateway_and_push_to_docker_hub:
    name: Push gateway Docker image to DockerHub
    runs-on: ubuntu-latest
    steps:
      - name: Check out the repo
        uses: actions/checkout@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      - name: Login to Docker 
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Push to DockerHub
        uses: docker/build-push-action@v4
        with:
          context: ./gateway/
          push: true
          # Тут вместо username должен быть ваш логин на Docker Hub
          tags: sergotis/taski_gateway:latest


  # Обновление проекта на боевом сервере
  deploy:
    name: Deploy to working server
    # Определяет, в каком окружении будут запущены все команды этой задачи. Окружение создаёт на своём сервере GitHub Actions.
    runs-on: ubuntu-latest
    # Не выполнять сразу, ждать, пока выполнятся задачи по сборке всех образов, перечисленных ниже (сами задачи описаны, выше по коду)
    needs:
      - build_backend_and_push_to_docker_hub
      - build_frontend_and_push_to_docker_hub
      - build_gateway_and_push_to_docker_hub
    steps:
    # Копируем код проекта в рабочую директорию раннера
    - name: Checkout repo
      uses: actions/checkout@v3
    # Копируем docker-compose.production.yml на продакшен-сервер
    - name: Copy docker-compose.yml via ssh
      uses: appleboy/scp-action@master
      # Передаём параметры для action appleboy/scp-action:
      # При помощи with передаём в action параметры для авторизации на удаленном сервере
      # Держать эти жанные прямо в текущем коде нельзя (он ведь будет запушен на гитаб)
      # Поэтому сохраняем их в репозитории проекта на GITHUB в ввиде констант
      # А далее передаем в формате ниже:
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USER }}
        key: ${{ secrets.SSH_KEY }}
        passphrase: ${{ secrets.SSH_PASSPHRASE }}
        # Копируемый файл. Т.к. он лежит в корне проекта, то путь не нужн, только имя файла
        source: "docker-compose.production.yml"
        # Целевой путь на сервере, должен быть каталогом ( обязательно )
        target: "taski"

      # Соединение с удалённым сервером по SSH и работа с ним «из терминала на раннере» для выполнения различных команд
    - name: Executing remote ssh commands to deploy
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USER }}
        key: ${{ secrets.SSH_KEY }}
        passphrase: ${{ secrets.SSH_PASSPHRASE }}
        # Параметр script передаёт в action appleboy/ssh-action команды, которые нужно выполнить на сервере, с которым установлено соединение
        script: |
          cd taski
          # Выполняет pull (обновление) образов с Docker Hub
          sudo docker compose -f docker-compose.production.yml pull
          # Перезапускает все контейнеры в Docker Compose:
          # удаляет контейнеры
          sudo docker compose -f docker-compose.production.yml down
          # запускает контейнеры (путем запуска Docker Compose в режиме демона)
          sudo docker compose -f docker-compose.production.yml up -d
          # Выполняет миграции и сбор статики и ее копирование
          sudo docker compose -f docker-compose.production.yml exec backend python manage.py migrate
          sudo docker compose -f docker-compose.production.yml exec backend python manage.py collectstatic
          sudo docker compose -f docker-compose.production.yml exec backend cp -r /app/collected_static/. /backend_static/static/

  # Telegram-бот для отправки уведомлений об успешном завершении задач
  send_message:
    runs-on: ubuntu-latest
    # Не выполнять сразу, ждать, пока выполнятся deploy, т.к. он выполняется последним.
    # Таким образом, если он выполнен успешно, то и предыдущие задачи так же выполнены успешно
    needs: deploy
    steps:
    - name: Send message
      uses: appleboy/telegram-action@master
      with:
        to: ${{ secrets.TELEGRAM_TO }}
        token: ${{ secrets.TELEGRAM_TOKEN }}
        message: Деплой успешно выполнен! 